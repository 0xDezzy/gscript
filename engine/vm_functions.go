// Code generated by go generate; DO NOT EDIT.
package engine

import (
	"github.com/robertkrimen/otto"
)

func (e *Engine) CreateVM() {
	e.VM = otto.New()
	e.InjectVars()
	e.VM.Set("Asset", e.VMAsset)
	e.VM.Set("RandomString", e.VMRandomString)
	e.VM.Set("RandomMixedCaseString", e.VMRandomMixedCaseString)
	e.VM.Set("RandomInt", e.VMRandomInt)
	e.VM.Set("XorBytes", e.VMXorBytes)
	e.VM.Set("StripSpaces", e.VMStripSpaces)
	e.VM.Set("ObfuscateString", e.VMObfuscateString)
	e.VM.Set("DeobfuscateString", e.VMDeobfuscateString)
	e.VM.Set("MD5", e.VMMD5)
	e.VM.Set("Timestamp", e.VMTimestamp)
	e.VM.Set("Halt", e.VMHalt)
	e.VM.Set("ExecuteCommand", e.VMExecuteCommand)
	e.VM.Set("ForkExecuteCommand", e.VMForkExecuteCommand)
	e.VM.Set("WriteFile", e.VMWriteFile)
	_, err := e.VM.Run(VMPreload)
	if err != nil {
		e.Logger.WithField("trace", "true").Fatalf("Syntax error in preload: %s", err.Error())
	}
	e.InitializeLogger()
}

// VMAsset is an autogenerated function.
// Function: Asset
// Package: core
// Description: Retrieves a packed asset from the VM embedded file store.
// Author: Alex
func (e *Engine) VMAsset(call otto.FunctionCall) otto.Value {
	if len(call.ArgumentList) > 1 {
		e.Logger.WithField("function", "Asset").WithField("trace", "true").Error("Too many arguments in call.")
		return otto.FalseValue()
	}
	if len(call.ArgumentList) < 1 {
		e.Logger.WithField("function", "Asset").WithField("trace", "true").Error("Too few arguments in call.")
		return otto.FalseValue()
	}

	var assetName string
	rawArg0, err := call.Argument(0).Export()
	if err != nil {
		e.Logger.WithField("function", "Asset").WithField("trace", "true").Errorf("Could not export field: %s", "assetName")
		return otto.FalseValue()
	}
	switch v := rawArg0.(type) {
	case string:
		assetName = rawArg0.(string)
	default:
		e.Logger.WithField("function", "Asset").WithField("trace", "true").Errorf("Argument type mismatch: expected %s, got %T", "string", v)
		return otto.FalseValue()
	}
	fileData, err := e.Asset(assetName)
	rawVMRet := VMResponse{}
	rawVMRet["fileData"] = fileData
	rawVMRet["err"] = err
	vmRet, vmRetError := e.VM.ToValue(rawVMRet)
	if vmRetError != nil {
		e.Logger.WithField("function", "Asset").WithField("trace", "true").Errorf("Return conversion failed: %s", vmRetError.Error())
		return otto.FalseValue()
	}
	return vmRet
}

// VMRandomString is an autogenerated function.
// Function: RandomString
// Package: core
// Description: Generates a random alpha numeric string of a specified length.
// Author: Alex
func (e *Engine) VMRandomString(call otto.FunctionCall) otto.Value {
	if len(call.ArgumentList) > 1 {
		e.Logger.WithField("function", "RandomString").WithField("trace", "true").Error("Too many arguments in call.")
		return otto.FalseValue()
	}
	if len(call.ArgumentList) < 1 {
		e.Logger.WithField("function", "RandomString").WithField("trace", "true").Error("Too few arguments in call.")
		return otto.FalseValue()
	}

	var strlen int64
	rawArg0, err := call.Argument(0).Export()
	if err != nil {
		e.Logger.WithField("function", "RandomString").WithField("trace", "true").Errorf("Could not export field: %s", "strlen")
		return otto.FalseValue()
	}
	switch v := rawArg0.(type) {
	case int64:
		strlen = rawArg0.(int64)
	default:
		e.Logger.WithField("function", "RandomString").WithField("trace", "true").Errorf("Argument type mismatch: expected %s, got %T", "int64", v)
		return otto.FalseValue()
	}
	value := e.RandomString(strlen)
	rawVMRet := VMResponse{}
	rawVMRet["value"] = value
	vmRet, vmRetError := e.VM.ToValue(rawVMRet)
	if vmRetError != nil {
		e.Logger.WithField("function", "RandomString").WithField("trace", "true").Errorf("Return conversion failed: %s", vmRetError.Error())
		return otto.FalseValue()
	}
	return vmRet
}

// VMRandomMixedCaseString is an autogenerated function.
// Function: RandomMixedCaseString
// Package: core
// Description: Generates a random mixed case alpha numeric string of a specified length.
// Author: Alex
func (e *Engine) VMRandomMixedCaseString(call otto.FunctionCall) otto.Value {
	if len(call.ArgumentList) > 1 {
		e.Logger.WithField("function", "RandomMixedCaseString").WithField("trace", "true").Error("Too many arguments in call.")
		return otto.FalseValue()
	}
	if len(call.ArgumentList) < 1 {
		e.Logger.WithField("function", "RandomMixedCaseString").WithField("trace", "true").Error("Too few arguments in call.")
		return otto.FalseValue()
	}

	var strlen int64
	rawArg0, err := call.Argument(0).Export()
	if err != nil {
		e.Logger.WithField("function", "RandomMixedCaseString").WithField("trace", "true").Errorf("Could not export field: %s", "strlen")
		return otto.FalseValue()
	}
	switch v := rawArg0.(type) {
	case int64:
		strlen = rawArg0.(int64)
	default:
		e.Logger.WithField("function", "RandomMixedCaseString").WithField("trace", "true").Errorf("Argument type mismatch: expected %s, got %T", "int64", v)
		return otto.FalseValue()
	}
	value := e.RandomMixedCaseString(strlen)
	rawVMRet := VMResponse{}
	rawVMRet["value"] = value
	vmRet, vmRetError := e.VM.ToValue(rawVMRet)
	if vmRetError != nil {
		e.Logger.WithField("function", "RandomMixedCaseString").WithField("trace", "true").Errorf("Return conversion failed: %s", vmRetError.Error())
		return otto.FalseValue()
	}
	return vmRet
}

// VMRandomInt is an autogenerated function.
// Function: RandomInt
// Package: core
// Description: Generates a random number between min and max.
// Author: Alex
func (e *Engine) VMRandomInt(call otto.FunctionCall) otto.Value {
	if len(call.ArgumentList) > 2 {
		e.Logger.WithField("function", "RandomInt").WithField("trace", "true").Error("Too many arguments in call.")
		return otto.FalseValue()
	}
	if len(call.ArgumentList) < 2 {
		e.Logger.WithField("function", "RandomInt").WithField("trace", "true").Error("Too few arguments in call.")
		return otto.FalseValue()
	}

	var min int64
	rawArg0, err := call.Argument(0).Export()
	if err != nil {
		e.Logger.WithField("function", "RandomInt").WithField("trace", "true").Errorf("Could not export field: %s", "min")
		return otto.FalseValue()
	}
	switch v := rawArg0.(type) {
	case int64:
		min = rawArg0.(int64)
	default:
		e.Logger.WithField("function", "RandomInt").WithField("trace", "true").Errorf("Argument type mismatch: expected %s, got %T", "int64", v)
		return otto.FalseValue()
	}

	var max int64
	rawArg1, err := call.Argument(1).Export()
	if err != nil {
		e.Logger.WithField("function", "RandomInt").WithField("trace", "true").Errorf("Could not export field: %s", "max")
		return otto.FalseValue()
	}
	switch v := rawArg1.(type) {
	case int64:
		max = rawArg1.(int64)
	default:
		e.Logger.WithField("function", "RandomInt").WithField("trace", "true").Errorf("Argument type mismatch: expected %s, got %T", "int64", v)
		return otto.FalseValue()
	}
	value := e.RandomInt(min, max)
	rawVMRet := VMResponse{}
	rawVMRet["value"] = value
	vmRet, vmRetError := e.VM.ToValue(rawVMRet)
	if vmRetError != nil {
		e.Logger.WithField("function", "RandomInt").WithField("trace", "true").Errorf("Return conversion failed: %s", vmRetError.Error())
		return otto.FalseValue()
	}
	return vmRet
}

// VMXorBytes is an autogenerated function.
// Function: XorBytes
// Package: core
// Description: XOR two byte arrays together.
// Author: Alex
func (e *Engine) VMXorBytes(call otto.FunctionCall) otto.Value {
	if len(call.ArgumentList) > 2 {
		e.Logger.WithField("function", "XorBytes").WithField("trace", "true").Error("Too many arguments in call.")
		return otto.FalseValue()
	}
	if len(call.ArgumentList) < 2 {
		e.Logger.WithField("function", "XorBytes").WithField("trace", "true").Error("Too few arguments in call.")
		return otto.FalseValue()
	}

	aByteArray := e.ValueToByteSlice(call.Argument(0))

	bByteArray := e.ValueToByteSlice(call.Argument(1))
	value := e.XorBytes(aByteArray, bByteArray)
	rawVMRet := VMResponse{}
	rawVMRet["value"] = value
	vmRet, vmRetError := e.VM.ToValue(rawVMRet)
	if vmRetError != nil {
		e.Logger.WithField("function", "XorBytes").WithField("trace", "true").Errorf("Return conversion failed: %s", vmRetError.Error())
		return otto.FalseValue()
	}
	return vmRet
}

// VMStripSpaces is an autogenerated function.
// Function: StripSpaces
// Package: core
// Description: Strip any unicode characters out of a string.
// Author: Alex
func (e *Engine) VMStripSpaces(call otto.FunctionCall) otto.Value {
	if len(call.ArgumentList) > 1 {
		e.Logger.WithField("function", "StripSpaces").WithField("trace", "true").Error("Too many arguments in call.")
		return otto.FalseValue()
	}
	if len(call.ArgumentList) < 1 {
		e.Logger.WithField("function", "StripSpaces").WithField("trace", "true").Error("Too few arguments in call.")
		return otto.FalseValue()
	}

	var str string
	rawArg0, err := call.Argument(0).Export()
	if err != nil {
		e.Logger.WithField("function", "StripSpaces").WithField("trace", "true").Errorf("Could not export field: %s", "str")
		return otto.FalseValue()
	}
	switch v := rawArg0.(type) {
	case string:
		str = rawArg0.(string)
	default:
		e.Logger.WithField("function", "StripSpaces").WithField("trace", "true").Errorf("Argument type mismatch: expected %s, got %T", "string", v)
		return otto.FalseValue()
	}
	value := e.StripSpaces(str)
	rawVMRet := VMResponse{}
	rawVMRet["value"] = value
	vmRet, vmRetError := e.VM.ToValue(rawVMRet)
	if vmRetError != nil {
		e.Logger.WithField("function", "StripSpaces").WithField("trace", "true").Errorf("Return conversion failed: %s", vmRetError.Error())
		return otto.FalseValue()
	}
	return vmRet
}

// VMObfuscateString is an autogenerated function.
// Function: ObfuscateString
// Package: core
// Description: Basic string obfuscator function.
// Author: Alex
func (e *Engine) VMObfuscateString(call otto.FunctionCall) otto.Value {
	if len(call.ArgumentList) > 1 {
		e.Logger.WithField("function", "ObfuscateString").WithField("trace", "true").Error("Too many arguments in call.")
		return otto.FalseValue()
	}
	if len(call.ArgumentList) < 1 {
		e.Logger.WithField("function", "ObfuscateString").WithField("trace", "true").Error("Too few arguments in call.")
		return otto.FalseValue()
	}

	var str string
	rawArg0, err := call.Argument(0).Export()
	if err != nil {
		e.Logger.WithField("function", "ObfuscateString").WithField("trace", "true").Errorf("Could not export field: %s", "str")
		return otto.FalseValue()
	}
	switch v := rawArg0.(type) {
	case string:
		str = rawArg0.(string)
	default:
		e.Logger.WithField("function", "ObfuscateString").WithField("trace", "true").Errorf("Argument type mismatch: expected %s, got %T", "string", v)
		return otto.FalseValue()
	}
	value := e.ObfuscateString(str)
	rawVMRet := VMResponse{}
	rawVMRet["value"] = value
	vmRet, vmRetError := e.VM.ToValue(rawVMRet)
	if vmRetError != nil {
		e.Logger.WithField("function", "ObfuscateString").WithField("trace", "true").Errorf("Return conversion failed: %s", vmRetError.Error())
		return otto.FalseValue()
	}
	return vmRet
}

// VMDeobfuscateString is an autogenerated function.
// Function: DeobfuscateString
// Package: core
// Description: Basic string deobfuscator function.
// Author: Alex
func (e *Engine) VMDeobfuscateString(call otto.FunctionCall) otto.Value {
	if len(call.ArgumentList) > 1 {
		e.Logger.WithField("function", "DeobfuscateString").WithField("trace", "true").Error("Too many arguments in call.")
		return otto.FalseValue()
	}
	if len(call.ArgumentList) < 1 {
		e.Logger.WithField("function", "DeobfuscateString").WithField("trace", "true").Error("Too few arguments in call.")
		return otto.FalseValue()
	}

	var str string
	rawArg0, err := call.Argument(0).Export()
	if err != nil {
		e.Logger.WithField("function", "DeobfuscateString").WithField("trace", "true").Errorf("Could not export field: %s", "str")
		return otto.FalseValue()
	}
	switch v := rawArg0.(type) {
	case string:
		str = rawArg0.(string)
	default:
		e.Logger.WithField("function", "DeobfuscateString").WithField("trace", "true").Errorf("Argument type mismatch: expected %s, got %T", "string", v)
		return otto.FalseValue()
	}
	value := e.DeobfuscateString(str)
	rawVMRet := VMResponse{}
	rawVMRet["value"] = value
	vmRet, vmRetError := e.VM.ToValue(rawVMRet)
	if vmRetError != nil {
		e.Logger.WithField("function", "DeobfuscateString").WithField("trace", "true").Errorf("Return conversion failed: %s", vmRetError.Error())
		return otto.FalseValue()
	}
	return vmRet
}

// VMMD5 is an autogenerated function.
// Function: MD5
// Package: core
// Description: Perform an MD5() hash on data.
// Author: Alex
func (e *Engine) VMMD5(call otto.FunctionCall) otto.Value {
	if len(call.ArgumentList) > 1 {
		e.Logger.WithField("function", "MD5").WithField("trace", "true").Error("Too many arguments in call.")
		return otto.FalseValue()
	}
	if len(call.ArgumentList) < 1 {
		e.Logger.WithField("function", "MD5").WithField("trace", "true").Error("Too few arguments in call.")
		return otto.FalseValue()
	}

	data := e.ValueToByteSlice(call.Argument(0))
	value := e.MD5(data)
	rawVMRet := VMResponse{}
	rawVMRet["value"] = value
	vmRet, vmRetError := e.VM.ToValue(rawVMRet)
	if vmRetError != nil {
		e.Logger.WithField("function", "MD5").WithField("trace", "true").Errorf("Return conversion failed: %s", vmRetError.Error())
		return otto.FalseValue()
	}
	return vmRet
}

// VMTimestamp is an autogenerated function.
// Function: Timestamp
// Package: core
// Description: Get the system's current timestamp in epoch format.
// Author: Alex
func (e *Engine) VMTimestamp(call otto.FunctionCall) otto.Value {
	if len(call.ArgumentList) > 0 {
		e.Logger.WithField("function", "Timestamp").WithField("trace", "true").Error("Too many arguments in call.")
		return otto.FalseValue()
	}
	if len(call.ArgumentList) < 0 {
		e.Logger.WithField("function", "Timestamp").WithField("trace", "true").Error("Too few arguments in call.")
		return otto.FalseValue()
	}
	value := e.Timestamp()
	rawVMRet := VMResponse{}
	rawVMRet["value"] = value
	vmRet, vmRetError := e.VM.ToValue(rawVMRet)
	if vmRetError != nil {
		e.Logger.WithField("function", "Timestamp").WithField("trace", "true").Errorf("Return conversion failed: %s", vmRetError.Error())
		return otto.FalseValue()
	}
	return vmRet
}

// VMHalt is an autogenerated function.
// Function: Halt
// Package: core
// Description: Stop the current VM from continuing execution.
// Author: Alex
func (e *Engine) VMHalt(call otto.FunctionCall) otto.Value {
	if len(call.ArgumentList) > 0 {
		e.Logger.WithField("function", "Halt").WithField("trace", "true").Error("Too many arguments in call.")
		return otto.FalseValue()
	}
	if len(call.ArgumentList) < 0 {
		e.Logger.WithField("function", "Halt").WithField("trace", "true").Error("Too few arguments in call.")
		return otto.FalseValue()
	}
	value := e.Halt()
	rawVMRet := VMResponse{}
	rawVMRet["value"] = value
	vmRet, vmRetError := e.VM.ToValue(rawVMRet)
	if vmRetError != nil {
		e.Logger.WithField("function", "Halt").WithField("trace", "true").Errorf("Return conversion failed: %s", vmRetError.Error())
		return otto.FalseValue()
	}
	return vmRet
}

// VMExecuteCommand is an autogenerated function.
// Function: ExecuteCommand
// Package: exec
// Description: Executes system commands.
// Author: Alex
func (e *Engine) VMExecuteCommand(call otto.FunctionCall) otto.Value {
	if len(call.ArgumentList) > 2 {
		e.Logger.WithField("function", "ExecuteCommand").WithField("trace", "true").Error("Too many arguments in call.")
		return otto.FalseValue()
	}
	if len(call.ArgumentList) < 2 {
		e.Logger.WithField("function", "ExecuteCommand").WithField("trace", "true").Error("Too few arguments in call.")
		return otto.FalseValue()
	}

	var baseCmd string
	rawArg0, err := call.Argument(0).Export()
	if err != nil {
		e.Logger.WithField("function", "ExecuteCommand").WithField("trace", "true").Errorf("Could not export field: %s", "baseCmd")
		return otto.FalseValue()
	}
	switch v := rawArg0.(type) {
	case string:
		baseCmd = rawArg0.(string)
	default:
		e.Logger.WithField("function", "ExecuteCommand").WithField("trace", "true").Errorf("Argument type mismatch: expected %s, got %T", "string", v)
		return otto.FalseValue()
	}

	var cmdArgs []string
	rawArg1, err := call.Argument(1).Export()
	if err != nil {
		e.Logger.WithField("function", "ExecuteCommand").WithField("trace", "true").Errorf("Could not export field: %s", "cmdArgs")
		return otto.FalseValue()
	}
	switch v := rawArg1.(type) {
	case []string:
		cmdArgs = rawArg1.([]string)
	default:
		e.Logger.WithField("function", "ExecuteCommand").WithField("trace", "true").Errorf("Argument type mismatch: expected %s, got %T", "[]string", v)
		return otto.FalseValue()
	}
	retObject := e.ExecuteCommand(baseCmd, cmdArgs)
	rawVMRet := VMResponse{}
	rawVMRet["retObject"] = retObject
	vmRet, vmRetError := e.VM.ToValue(rawVMRet)
	if vmRetError != nil {
		e.Logger.WithField("function", "ExecuteCommand").WithField("trace", "true").Errorf("Return conversion failed: %s", vmRetError.Error())
		return otto.FalseValue()
	}
	return vmRet
}

// VMForkExecuteCommand is an autogenerated function.
// Function: ForkExecuteCommand
// Package: exec
// Description: Executes system commands via a forked call.
// Author: Alex
func (e *Engine) VMForkExecuteCommand(call otto.FunctionCall) otto.Value {
	if len(call.ArgumentList) > 2 {
		e.Logger.WithField("function", "ForkExecuteCommand").WithField("trace", "true").Error("Too many arguments in call.")
		return otto.FalseValue()
	}
	if len(call.ArgumentList) < 2 {
		e.Logger.WithField("function", "ForkExecuteCommand").WithField("trace", "true").Error("Too few arguments in call.")
		return otto.FalseValue()
	}

	var baseCmd string
	rawArg0, err := call.Argument(0).Export()
	if err != nil {
		e.Logger.WithField("function", "ForkExecuteCommand").WithField("trace", "true").Errorf("Could not export field: %s", "baseCmd")
		return otto.FalseValue()
	}
	switch v := rawArg0.(type) {
	case string:
		baseCmd = rawArg0.(string)
	default:
		e.Logger.WithField("function", "ForkExecuteCommand").WithField("trace", "true").Errorf("Argument type mismatch: expected %s, got %T", "string", v)
		return otto.FalseValue()
	}

	var cmdArgs []string
	rawArg1, err := call.Argument(1).Export()
	if err != nil {
		e.Logger.WithField("function", "ForkExecuteCommand").WithField("trace", "true").Errorf("Could not export field: %s", "cmdArgs")
		return otto.FalseValue()
	}
	switch v := rawArg1.(type) {
	case []string:
		cmdArgs = rawArg1.([]string)
	default:
		e.Logger.WithField("function", "ForkExecuteCommand").WithField("trace", "true").Errorf("Argument type mismatch: expected %s, got %T", "[]string", v)
		return otto.FalseValue()
	}
	pid, execError := e.ForkExecuteCommand(baseCmd, cmdArgs)
	rawVMRet := VMResponse{}
	rawVMRet["pid"] = pid
	rawVMRet["execError"] = execError
	vmRet, vmRetError := e.VM.ToValue(rawVMRet)
	if vmRetError != nil {
		e.Logger.WithField("function", "ForkExecuteCommand").WithField("trace", "true").Errorf("Return conversion failed: %s", vmRetError.Error())
		return otto.FalseValue()
	}
	return vmRet
}

// VMWriteFile is an autogenerated function.
// Function: WriteFile
// Package: file
// Description: Writes data from a byte array to a file with the given permissions.
// Author: Alex
func (e *Engine) VMWriteFile(call otto.FunctionCall) otto.Value {
	if len(call.ArgumentList) > 3 {
		e.Logger.WithField("function", "WriteFile").WithField("trace", "true").Error("Too many arguments in call.")
		return otto.FalseValue()
	}
	if len(call.ArgumentList) < 3 {
		e.Logger.WithField("function", "WriteFile").WithField("trace", "true").Error("Too few arguments in call.")
		return otto.FalseValue()
	}

	var path string
	rawArg0, err := call.Argument(0).Export()
	if err != nil {
		e.Logger.WithField("function", "WriteFile").WithField("trace", "true").Errorf("Could not export field: %s", "path")
		return otto.FalseValue()
	}
	switch v := rawArg0.(type) {
	case string:
		path = rawArg0.(string)
	default:
		e.Logger.WithField("function", "WriteFile").WithField("trace", "true").Errorf("Argument type mismatch: expected %s, got %T", "string", v)
		return otto.FalseValue()
	}

	fileData := e.ValueToByteSlice(call.Argument(1))

	var perms int64
	rawArg2, err := call.Argument(2).Export()
	if err != nil {
		e.Logger.WithField("function", "WriteFile").WithField("trace", "true").Errorf("Could not export field: %s", "perms")
		return otto.FalseValue()
	}
	switch v := rawArg2.(type) {
	case int64:
		perms = rawArg2.(int64)
	default:
		e.Logger.WithField("function", "WriteFile").WithField("trace", "true").Errorf("Argument type mismatch: expected %s, got %T", "int64", v)
		return otto.FalseValue()
	}
	bytesWritten, fileError := e.WriteFile(path, fileData, perms)
	rawVMRet := VMResponse{}
	rawVMRet["bytesWritten"] = bytesWritten
	rawVMRet["fileError"] = fileError
	vmRet, vmRetError := e.VM.ToValue(rawVMRet)
	if vmRetError != nil {
		e.Logger.WithField("function", "WriteFile").WithField("trace", "true").Errorf("Return conversion failed: %s", vmRetError.Error())
		return otto.FalseValue()
	}
	return vmRet
}
